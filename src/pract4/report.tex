\graphicspath{{./img/}}
\section{Описание используемого программного обеспечения
	и сетевая топология его развертывания}

\subsection{Используемое программное обеспечение}

В данном проекте для мониторинга
и журналирования использовалось следующее программное обеспечение:

\begin{itemize}
    \item \textbf{Python}: Основной язык программирования
		для разработки приложения,
		выполняющего скалярное произведение векторов
		и ведения системных журналов.
    \item \textbf{Loki}: Система хранения и агрегирования логов,
		предназначенная для работы с высокими объемами данных.
		Loki позволяет собирать,
		хранить и запрашивать логи с низкой нагрузкой на ресурсы.
    \item \textbf{Promtail}: Инструмент для сбора и отправки логов в Loki.
		Promtail может следить за изменениями в файловой системе
		и автоматически отправлять новые записи журналов в Loki.
    \item \textbf{Grafana}: Платформа для визуализации и анализа данных.
		Grafana предоставляет интерфейс для создания дашбордов
		и построения графиков на основе данных, полученных из Loki.
\end{itemize}

\subsection{Создание приложения}

Приложение, написанное на \textbf{Python},
выполняет поиск простых чисел до заданного n и ведет системный журнал,
фиксируя результаты операций и обращения в кеш.
В процессе разработки было реализовано логирование
с использованием стандартной библиотеки \texttt{logging}. 

\break

\lstinputlisting[
	language=bash,
	caption=\leftline{Приложение для простых чисел}
	]{src/pract4Monitoring/main.py}

\subsection{Создание контейнеров}

Для упрощения развертывания системы был использован \textbf{Docker Compose}.
Это позволяет легко настраивать
и управлять различными компонентами системы в контейнерах.

Для создания файла \texttt{compose.yml}
придерживались инструкций в документации
\href{https://grafana.com/docs/loki/latest/setup/install/docker/}{Grafana}.

\lstinputlisting[
	language=bash,
	caption=\leftline{compose}
	]{src/pract4Monitoring/compose.yml}

Далее выполнили следующую команду 'docker-compose'.

\begin{lstlisting}[
	language=bash,
	caption=\leftline{Запуск Docker-контейнеров}
	]
docker-compose up
\end{lstlisting}

После запуска контейнеров убедились, что Loki работает:
\begin{itemize}
	\item Проверили готовность:
		\url{http://localhost:3100/ready} \rref{fig:loki:ready}.
	\item Просмотрели метрики:
		\url{http://localhost:3100/metrics} \rref{fig:loki:metrics}.
\end{itemize}

\begin{image}
    \includegrph{ready}
    \caption{Страница localhost:3100/ready}
    \label{fig:loki:ready}
\end{image}

\begin{image}
    \includegrph{metrics}
    \caption{Страница localhost:3100/metrics}
    \label{fig:loki:metrics}
\end{image}

\subsection{Создание Dashboards}

После запуска контейнеров Grafana должна быть доступна
по адресу:\url{http://localhost:3000}.

Для анализа системного журнала создадим дашборд
с 3 визуализациями: общее количество логов, количество ошибок
и последнте логи (live logs)\rref{fig:dashboard}.

\begin{image}
    \includegrph[scale=0.25]{dashboard}
    \caption{Dashboards с тремя визуализациями}
    \label{fig:dashboard}
\end{image}

\subsubsection{Источник данных}

Далее необходимо проверить подключенность источника данных Loki
\rref{fig:datasource}.
Для этого перешли в Configuration далее Data Sources.
Если их нет, то нужно нажать кнопку \textbf{Add data source},
выбрать тип источника данных (Loki), настроить параметры подключения
и нажать \textbf{Save \& Test} для проверки соединения.

\begin{image}
	\includegrph[scale=0.35]{Screenshot from 2024-10-16 11-25-55}
    \caption{Источник данных Loki}
    \label{fig:datasource}
\end{image}

\subsubsection{Визуализация скорости вычислений}

В дашборде создали визуализацию  скорости вычислений \rref{fig:vis:total}.
Для этого выбрали тип графика <<Stat>> для отображения числа.
В разделе \textbf{Query} настроили запросы :

\begin{lstlisting}[
	language=sql, caption=\leftline{Запрос для получение новых числел}]
sum(rate({filename="/var/log/main.log"} |~ `Найдено новое простое число: \d+` [1m]))
\end{lstlisting}

\begin{lstlisting}[
	language=sql, caption=\leftline{Запрос для получение новых числел из кеша}]
sum(rate({filename="/var/log/main.log"} |~ `найдено в кэше:` [1m]))
\end{lstlisting}

\clearpage
\begin{image}
    \includegrph[scale=0.35]{vis-total}
    \caption{Создание визуализации скорости вычислений}
    \label{fig:vis:total}
\end{image}

\subsubsection{Визуализация количества ошибок}

В дашборде создали визуализацию количества ошибок \rref{fig:vis:errors}.
Для этого выбрали тип графика <<Gaue>> для отображения числа.
В разделе \textbf{Query} настроили запрос
для получения общего количества логов:

\begin{lstlisting}[
	language=sql, caption=\leftline{Запрос для получение количества ошибок}]
sum(rate({filename="/var/log/main.log"} |= `Кеш не ответил` [1m]))
\end{lstlisting}


\begin{image}
    \includegrph[scale=0.25]{vis-errors}
    \caption{Создание визуализации количества ошибок}
    \label{fig:vis:errors}
\end{image}
\clearpage

\subsubsection{Визуализация последних логов (live logs)}

В дашборде создали визуализацию последних логов \rref{fig:vis:live}.
Для этого выбрали тип графика <<Stat>> для отображения числа.
В разделе \textbf{Query} настроили запрос для получения последних логов:

\begin{lstlisting}[
	language=sql, caption=\leftline{Запрос для получения последних логов}]
{filename="/var/log/main.log"}
\end{lstlisting}

\begin{image}
    \includegrph[scale=0.25]{vis-live}
    \caption{Создание визуализации последних логов}
    \label{fig:vis:live}
\end{image}

\subsection{Сетевая топология развертывания}

Все компоненты системы развернуты на одном сервере (localhost)
для целей тестирования:

\begin{itemize}
    \item Приложение Python, использующее журналирование.
    \item Loki работает на порту 3100,
		принимая запросы на получение и хранение логов.
    \item Promtail работает на порту 9080,
		собирая журналы из файла приложения и отправляя их в Loki.
    \item Grafana работает на порту 3000
		и служит для визуализации собранных логов.
\end{itemize}

\begin{figure}[h!tp]
	\includegrph{net}
    \caption{Архитектура сетевой топологии сети}
    \label{fig:vm:run:web}
\end{figure}

\section{Создание системного журнала,
	описание содержащихся в нем данных и их разметки}

Системный журнал служит для отслеживания жизненного цикла приложения,
включая запуск, выполнение операций,
а также ошибки, которые могут возникнуть в процессе.
Он полезен для диагностики и мониторинга работы программы,
позволяя разработчику понять, что произошло в ходе выполнения.
Журнал создается в директории \texttt{log}
и может быть проанализирован для улучшения стабильности
и производительности приложения.

\subsection{Структура журнала}

Системный журнал приложения использует модуль \texttt{logging}
для записи информации о выполнении программы.
Журнал сохраняется в файл \texttt{main.log} и содержит следующие данные:

\begin{itemize}
    \item \textbf{Дата и время}:
		Время, когда произошло событие,
		записывается в формате \texttt{YYYY-MM-DD HH:MM:SS}.
    \item \textbf{Уровень важности}:
		Указывает уровень сообщения (например, \texttt{INFO}, \texttt{ERROR}).
    \item \textbf{Сообщение}:
		Содержит текстовое сообщение, описывающее событие.
\end{itemize}

\subsection{Формат записи}

Формат записи определяется в настройках логирования.
Представляет собой описаные ранее поля разделенные вертикальной чертой.

\begin{lstlisting}[language=Python, caption=\leftline{Форматирование строки лога}]
	"%(asctime)s | %(levelname)s | %(message)s"
\end{lstlisting}

\subsection{Примеры записей в журнале}

В зависимости от выполнения программы, журнал может содержать следующие записи:

\begin{lstlisting}[
	language=bash,
	caption=\leftline{Число нашлось в кеше}]
Число 376627 найдено в кэше: True
\end{lstlisting}

\begin{lstlisting}[
	language=bash, caption=\leftline{Ошибка при запросе кеша}]
2024-12-04 03:00:31,980 | ERROR | Кеш не ответил
\end{lstlisting}

\begin{lstlisting}[
	language=bash, caption=\leftline{Успешное вычисление}]
2024-12-04 03:00:31,966 | INFO | Найдено новое простое число: 246899
\end{lstlisting}



\section{Анализ полученных в ходе работы результатов}

В ходе работы была настроена система мониторинга,
которая позволяет отслеживать состояние приложения
и выявлять возможные проблемы.
Основные результаты анализа:

\begin{itemize}
	\item \textbf{Успешные вычисления}:
	Приложение успешно выполняло операции, такие как нахождение простых чисел, их кэширование и запись в системный
	журнал.
	Все успешные операции фиксировались с соответствующими уровнями логирования (\texttt{INFO}), что позволило
	отслеживать их корректное выполнение.

	\item \textbf{Ошибки и исключения}:
	Приложение фиксировало ошибки, возникающие при некорректной работе, такие как сбой в запросах к кэшу или попытки
	выполнять недопустимые операции.
	Эти ошибки регистрировались с уровнем логирования (\texttt{ERROR}) и содержали информацию об их причинах.
	Примеры таких ошибок анализировались для устранения неполадок.

	\item \textbf{Сбор и визуализация данных}:
	Благодаря интеграции с Loki и Grafana, данные из системных журналов собирались и визуализировались.
	Это позволило:
	\begin{itemize}
		\item отслеживать количество ошибок;
		\item наблюдать динамику их возникновения;
		\item выявлять повторяющиеся паттерны поведения приложения.
	\end{itemize}
	Дашборды Grafana предоставили удобный интерфейс для анализа логов, настройки алертов и создания метрик для дальнейшего улучшения системы.
\end{itemize}

Система мониторинга и журналирования значительно улучшила возможность
отслеживания состояния приложения.
Логи позволяют быстро реагировать на возникшие проблемы,
а визуализация в Grafana помогает анализировать данные
в режиме реального времени,
что позволяет оперативно принимать решения
для улучшения работы приложения.

\clearpage

\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}

Система мониторинга и журналирования,
реализованная с использованием Python, Loki, Promtail и Grafana,
продемонстрировала свою эффективность в отслеживании состояния приложения
и быстром реагировании на возникшие проблемы.
Настроенные логи позволяют проводить глубокий анализ работы приложения
и выявлять возможные точки улучшения.

\clearpage

\section*{Ответы на контрольные вопросы}
\addcontentsline{toc}{section}{Ответы на контрольные вопросы}

\subsection*{Понятие системного журнала}

\textbf{Системный журнал} --- это специализированная база данных или файл,
в котором регистрируются события, происходящие в операционной системе,
приложениях или устройствах.
Журналы могут содержать информацию о системных событиях, ошибках,
предупреждениях и информационных сообщениях,
что позволяет отслеживать состояние системы и выполнять диагностику.

\subsection*{Задача сбора системных журналов}

Основная задача сбора системных журналов заключается
в централизованной агрегации, хранении
и анализе событий для обеспечения мониторинга,
диагностики и устранения неисправностей.
Это позволяет администраторам и инженерам безопасности отслеживать аномалии,
выявлять инциденты и принимать меры по их предотвращению.

\subsection*{Сбор системных журналов с помощью sidecar}

\textbf{Sidecar} --- это паттерн архитектуры,
при котором дополнительный сервис (контейнер) работает рядом
с основным приложением и отвечает за сбор его логов.
Он может перехватывать вывод приложения, обрабатывать его
(например, фильтровать или форматировать)
и отправлять в систему централизованного хранения,
такой как ELK Stack или Fluentd.

\subsection*{Индексация и поиск в данных Loki}

\textbf{Loki} --- это система для сбора и хранения логов,
которая позволяет индексировать метаданные логов, но не сами сообщения.
Поиск осуществляется с помощью меток, что упрощает и ускоряет процесс поиска.
Пользователи могут выполнять запросы на основе меток
и использовать Grafana для визуализации данных.

